annotation_colors = colorList, labels_row = labels_row0,
gaps_col = 1,
# legend_breaks = seq2,legend_labels = legend_labels,
border_color = 'black',
fontsize = 8,fontsize_row = 5, fontsize_col = 8,
cellwidth = 12, cellheight = 5,
cluster_rows = TRUE,cluster_cols = FALSE,
display_numbers = sigTbl, number_color = 'Black',fontsize_number = 5)
dev.off()
################plot4: realDist and rel corr -- target Out##########
mat = read.csv('output/relCorr_heatmapTbl_realDist_targetOut.csv')
sig = read.csv('output/heatmapTbl_sigLabel_realDist_targetOut.csv')
boundary = read.csv('output/heatmapTbl_boundaries_realDist_targetOut.csv')
heatTbl = mat[,2:ncol(mat)]
colnames(heatTbl) = boundary$Var1[1:(ncol(mat)-1)]
rownames(heatTbl) = mat$Row
sigTbl = ifelse(sig[,2:ncol(mat)]==1, '+','')
dev.off()
pdf('figures/boundary_heatmap_realDist.pdf',width = 24,height = 14)
dev.off()
################plot3: realDist and rel corr##########
mat = read.csv('output/relCorr_heatmapTbl_realDist.csv')
sig = read.csv('output/heatmapTbl_sigLabel_realDist.csv')
boundary = read.csv('output/heatmapTbl_boundaries_realDist.csv')
heatTbl = mat[,2:ncol(mat)]
colnames(heatTbl) = boundary$Var1[1:(ncol(mat)-1)]
rownames(heatTbl) = mat$Row
sigTbl = ifelse(sig[,2:ncol(mat)]==1, '+','')
dev.off()
pdf('figures/boundary_heatmap_realDist.pdf',width = 24,height = 14)
# we do row-wise left nearest impute: the prediction should be same to the left-most one if no new reaction can be seen as the distance boundary increase
for (i in 1:nrow(heatTbl)){
for (j in 1:(ncol(heatTbl))){
if (is.na(heatTbl[i,j])){
p1 = heatTbl[i,1:j-1]
p1 = p1[!is.na(p1)]
# p2 = heatTbl[i,(j+1):ncol(heatTbl)]
# p2 = p2[!is.na(p2)]
s1 = sigTbl[i,1:j-1]
s1 = s1[!is.na(p1)]
heatTbl[i,j] = p1[length(p1)]#mean(c(p1[length(p1)],p2[1]))
sigTbl[i,j] = s1[length(s1)]#mean(c(p1[length(p1)],p2[1]))
}
}
}
#heatTbl[is.na(heatTbl)] = 0
# reorder according to annotation table
library(xlsx)
annTbl = read.xlsx('./output/predictionMechanism_annotation.xlsx','Sheet1',header = T)
rownames(sigTbl) = rownames(heatTbl)
heatTbl = heatTbl[annTbl$rxn,]
sigTbl = sigTbl[annTbl$rxn,]
labels_row0 = paste(rownames(heatTbl),annotation[rownames(heatTbl),'pathway'])
pheatmap(heatTbl[,1:38], breaks = seq(0,1,0.001),color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdYlBu")))(1000),
# clustering_distance_rows = as.dist(1 - rows.cor),
annotation_row = annotation[,c("pathway_major"),drop = F],
annotation_colors = colorList, labels_row = labels_row0,
gaps_col = 1,
# legend_breaks = seq2,legend_labels = legend_labels,
border_color = 'black',
fontsize = 8,fontsize_row = 5, fontsize_col = 8,
cellwidth = 12, cellheight = 5,
cluster_rows = FALSE,cluster_cols = FALSE
,display_numbers = sigTbl[,1:38], number_color = 'Black',fontsize_number = 5
)
dev.off()
################plot4: realDist and rel corr -- target Out##########
mat = read.csv('output/relCorr_heatmapTbl_realDist_targetOut.csv')
sig = read.csv('output/heatmapTbl_sigLabel_realDist_targetOut.csv')
boundary = read.csv('output/heatmapTbl_boundaries_realDist_targetOut.csv')
heatTbl = mat[,2:ncol(mat)]
colnames(heatTbl) = boundary$Var1[1:(ncol(mat)-1)]
rownames(heatTbl) = mat$Row
sigTbl = ifelse(sig[,2:ncol(mat)]==1, '+','')
dev.off()
pdf('figures/boundary_heatmap_realDist_targetOut.pdf',width = 24,height = 14)
# we do row-wise left nearest impute: the prediction should be same to the left-most one if no new reaction can be seen as the distance boundary increase
for (i in 1:nrow(heatTbl)){
for (j in 1:(ncol(heatTbl))){
if (is.na(heatTbl[i,j])){
p1 = heatTbl[i,1:j-1]
p1 = p1[!is.na(p1)]
# p2 = heatTbl[i,(j+1):ncol(heatTbl)]
# p2 = p2[!is.na(p2)]
s1 = sigTbl[i,1:j-1]
s1 = s1[!is.na(p1)]
heatTbl[i,j] = p1[length(p1)]#mean(c(p1[length(p1)],p2[1]))
sigTbl[i,j] = s1[length(s1)]#mean(c(p1[length(p1)],p2[1]))
}
}
}
#heatTbl[is.na(heatTbl)] = 0
# reorder according to annotation table
library(xlsx)
annTbl = read.xlsx('./output/predictionMechanism_annotation.xlsx','Sheet1',header = T)
rownames(sigTbl) = rownames(heatTbl)
heatTbl = heatTbl[annTbl$rxn,]
sigTbl = sigTbl[annTbl$rxn,]
labels_row0 = paste(rownames(heatTbl),annotation[rownames(heatTbl),'pathway'])
pheatmap(heatTbl[,1:38], breaks = seq(0,1,0.001),color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdYlBu")))(1000),
# clustering_distance_rows = as.dist(1 - rows.cor),
annotation_row = annotation[,c("pathway_major"),drop = F],
annotation_colors = colorList, labels_row = labels_row0,
gaps_col = 1,
# legend_breaks = seq2,legend_labels = legend_labels,
border_color = 'black',
fontsize = 8,fontsize_row = 5, fontsize_col = 8,
cellwidth = 12, cellheight = 5,
cluster_rows = FALSE,cluster_cols = FALSE
,display_numbers = sigTbl[,1:38], number_color = 'Black',fontsize_number = 5
)
dev.off()
library(pheatmap)
library(RColorBrewer)
# the annotation of reactions
# the manual connected pathway was used; pathways with reactions less than 3 were grouped to others; isolated transporters are labeled out (inner and exchange)
mat = read.csv('output/relCorr_heatmapTbl_realDist.csv')
sig = read.csv('output/heatmapTbl_sigLabel_realDist.csv')
boundary = read.csv('output/heatmapTbl_boundaries_realDist.csv')
View(mat)
heatTbl = mat[,2:ncol(mat)]
colnames(heatTbl) = boundary$Var1[1:(ncol(mat)-1)]
rownames(heatTbl) = mat$Row
View(heatTbl)
sigTbl = ifelse(sig[,2:ncol(mat)]==1, '+','')
dev.off()
pdf('figures/boundary_heatmap_realDist.pdf',width = 30,height = 17.5)
# we do row-wise left nearest impute: the prediction should be same to the left-most one if no new reaction can be seen as the distance boundary increase
for (i in 1:nrow(heatTbl)){
for (j in 1:(ncol(heatTbl))){
if (is.na(heatTbl[i,j])){
p1 = heatTbl[i,1:j-1]
p1 = p1[!is.na(p1)]
s1 = sigTbl[i,1:j-1]
s1 = s1[!is.na(p1)]
heatTbl[i,j] = p1[length(p1)]#mean(c(p1[length(p1)],p2[1]))
sigTbl[i,j] = s1[length(s1)]#mean(c(p1[length(p1)],p2[1]))
}
}
}
# reorder according to annotation table
library(xlsx)
annTbl = read.xlsx('./pathway_annotations.xlsx','all',header = T)
rownames(annTbl) = annTbl$rxn
annTbl = annTbl[rownames(annTbl) %in% rownames(heatTbl),]
annotationList = c('Purine metabolism','Phenylalanine, tyrosine and tryptophan biosynthesis','Histidine metabolism','Lysine biosynthesis',
'Arginine biosynthesis','Threonine, methionine and cysteine synthesis','Proline biosynthesis','Pyrimidine metabolism',
'Glycolysis','TCA cycle', 'Mannan synthesis',
'UDP-D-glucose metabolism','Fatty acid biosynthesis',
'transporter [inner]','transporter [exchange]','Others')
# reorder according to annotation table
library(xlsx)
annTbl = read.xlsx('./pathway_annotations.xlsx','all',header = T)
rownames(annTbl) = annTbl$rxn
annTbl = annTbl[rownames(annTbl) %in% rownames(heatTbl),]
annotationList = c('Purine metabolism','Phenylalanine, tyrosine and tryptophan biosynthesis','Histidine metabolism','Lysine biosynthesis',
'Arginine biosynthesis','Threonine, methionine and cysteine synthesis','Proline biosynthesis','Pyrimidine metabolism',
'Glycolysis','TCA cycle', 'Mannan synthesis',
'UDP-D-glucose metabolism','Fatty acid biosynthesis',
'Transporter [inner]','Transporter [exchange]','Others')
colorList2 = colors$V1[2:(1+length(annotationList))]
colors = read.csv('figures/simpsons_color.csv',header = F)
colorList2 = colors$V1[2:(1+length(annotationList))]
names(colorList2) = annotationList
colorList2 = list(functional_annotation = colorList2)
colorList2$functional_annotation = colorList2$functional_annotation[unique(annTbl[,c("functional_annotation")])]
colorList2
# assign annotations
rownames(sigTbl) = rownames(heatTbl)
heatTbl = heatTbl[annTbl$rxn,]
sigTbl = sigTbl[annTbl$rxn,]
ann2 = annTbl[rownames(annTbl),"connected_pathway"]
ann2[ann2 == 'NA'] = annTbl$pathway[ann2 == 'NA']
ann2
ann2[ann2 == 'NA'] = annTbl$pathway[ann2 == 'NA']
annTbl$pathway[ann2 == 'NA']
ann2
# reorder according to annotation table
library(xlsx)
annTbl = read.xlsx('./pathway_annotations.xlsx','all',header = T)
rownames(annTbl) = annTbl$rxn
annTbl = annTbl[rownames(annTbl) %in% rownames(heatTbl),]
annotationList = c('Purine metabolism','Phenylalanine, tyrosine and tryptophan biosynthesis','Histidine metabolism','Lysine biosynthesis',
'Arginine biosynthesis','Threonine, methionine and cysteine synthesis','Proline biosynthesis','Pyrimidine metabolism',
'Glycolysis','TCA cycle', 'Mannan synthesis',
'UDP-D-glucose metabolism','Fatty acid biosynthesis',
'Transporter [inner]','Transporter [exchange]','Others')
colors = read.csv('figures/simpsons_color.csv',header = F)
colorList2 = colors$V1[2:(1+length(annotationList))]
names(colorList2) = annotationList
colorList2 = list(functional_annotation = colorList2)
colorList2$functional_annotation = colorList2$functional_annotation[unique(annTbl[,c("functional_annotation")])]
# assign annotations
rownames(sigTbl) = rownames(heatTbl)
heatTbl = heatTbl[annTbl$rxn,]
sigTbl = sigTbl[annTbl$rxn,]
ann2 = annTbl[rownames(annTbl),"connected_pathway"]
ann2[ann2 == 'NA'] = annTbl$pathway[ann2 == 'NA']
labels_row0 = paste(rownames(annTbl),ann2)
pheatmap(heatTbl[,1:23], breaks = seq(0,1,0.001),color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdYlBu")))(1000),
# clustering_distance_rows = as.dist(1 - rows.cor),
annotation_row = annTbl[,c("functional_annotation"),drop = F],
annotation_colors = colorList2, labels_row = labels_row0,
gaps_col = c(1,2),
# legend_breaks = seq2,legend_labels = legend_labels,
border_color = 'black',
fontsize = 8,fontsize_row = 6, fontsize_col = 8,
cellwidth = 12, cellheight = 6,
cluster_rows = FALSE,cluster_cols = FALSE
,display_numbers = sigTbl[,1:23], number_color = 'Black',fontsize_number = 6
)
dev.off()
# plot the subset showcase
library(parallel)
smooth.expr <- function(mat, x, x.pred) {
n <- length(x.pred)
nd <- data.frame(x=x.pred)
tmp <- mclapply(1:nrow(mat), function(i) {
fit <- loess(mat[i, ] ~ x, span=0.1, degree=2)
predict(fit, newdata=nd, se=FALSE)
})
expr.fit <- t(matrix(unlist(tmp), n))
rownames(expr.fit) <- rownames(mat)
colnames(expr.fit) <- nd$x
return(expr.fit)
}
library(lsa)
tg_fit <- smooth.expr(as.matrix(heatTbl[,3:23]),as.numeric(colnames(heatTbl)[3:23]),seq(0,20,0.01))
dev.off()
png('figures/boundary_heatmap_realDist_small.png',width = 600,height = 600)
pheatmap(tg_fit, breaks = seq(0,1,0.001),color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdYlBu")))(1000),
annotation_row = annTbl[,c("functional_annotation"),drop = F],
annotation_colors = colorList2,
border_color = 0,
cluster_rows = F,cluster_cols = FALSE,show_rownames = F,show_colnames = F
)
dev.off()
# smooth to make the trend of change more visually clear
annTbl = read.xlsx('./pathway_annotations.xlsx','selected',header = T)
rownames(annTbl) = annTbl$rxn
annTbl = annTbl[rownames(annTbl) %in% rownames(heatTbl),]
heatTbl = heatTbl[annTbl$rxn,]
sigTbl = sigTbl[annTbl$rxn,]
labels_row0 = paste(rownames(annTbl),annTbl[rownames(annTbl),"functional_annotation"])
tg_fit <- smooth.expr(as.matrix(heatTbl[,3:23]),as.numeric(colnames(heatTbl)[3:23]),seq(0,20,0.01))
gaps = c(0)
for (i in 1:(nrow(annTbl)-1)){
if(annTbl$functional_annotation[i] != annTbl$functional_annotation[i+1]){
gaps = c(gaps, i)
}
}
colorList3 = colorList2
colorList3$functional_annotation = colorList3$functional_annotation[unique(annTbl[,c("functional_annotation")])]
dev.off()
png('figures/boundary_heatmap_realDist_smooth.png',width = 1200,height = 800)
pheatmap(tg_fit, breaks = seq(0,1,0.001),color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdYlBu")))(1000),
annotation_row = annTbl[,c("functional_annotation"),drop = F],
annotation_colors = colorList3, #labels_row = labels_row0,
show_colnames = F, show_rownames = F,
border_color = 0,
gaps_row = gaps,
cluster_rows = FALSE,cluster_cols = FALSE
)
dev.off()
# this script analyzed the pathway-level coexpression and pathway-level flux-expression correlation
library(pheatmap)
library(RColorBrewer)
library(matrixStats)
# relPCCtbl = mat[,2:ncol(mat)]
# colnames(relPCCtbl) = boundary$Var1[1:(ncol(mat)-1)]
# rownames(relPCCtbl) = mat$Row
# relPCCtbl$absPCC_default = FPAtbl[rownames(relPCCtbl),"PCC_by_default_FPA"]
# relPCCtbl$maxAbsPCC = relPCCtbl$absPCC_default / relPCCtbl$`base 2 - boundary 6`
PCCs = read.csv('output/PCC_titration_all.csv',row.names = 1)
View(PCCs)
boundary = read.csv('output/heatmapTbl_boundaries.csv')
seq(0,40,0.5)
boundary = data.frame(Var1 = c(c('base2-boundary6','expression only'), seq(0,40,0.5)))
boundary
FPAtbl = read.csv('output/summary_table_reaction_information.csv',row.names = 1)
PCCs = read.csv('output/PCC_titration_all.csv',row.names = 1)
colnames(PCCs) = boundary$Var1[1:(ncol(mat)-1)]
colnames(PCCs) = boundary$Var1
View(PCCs)
View(PCCs)
FPAtbl$maxPCC = rowMaxs(as.matrix(PCCs[rownames(FPAtbl),3:ncol(PCCs)]))
library(stringr)
annotation = read.xlsx('./pathway_annotations.xlsx','more_info',header = T)
library(xlsx)
annotation = read.xlsx('./pathway_annotations.xlsx','more_info',header = T)
View(annotation)
rownames(annotation) = annotation$rxn
#correlation between coexpression levels and flux-expression concordance levels
ExpMat = read.csv('output/relativeExpressionTable.csv',row.names = 1)
#correlation between coexpression levels and flux-expression concordance levels
ExpMat = read.csv('output/supp1D_normalizedExpression.csv',row.names = 1)
View(ExpMat)
rows.cor.exp <- cor(t(ExpMat), use = "pairwise.complete.obs", method = "pearson")
pathways = setdiff(unique(annotation$connected_pathways),NA)
pathways
cmpTbl = data.frame(pathways)
cmpTbl$ave_coexpression = NA
cmpTbl$median_coexpression = NA
cmpTbl$ave_FPA_corr = NA
cmpTbl$median_FPA_corr = NA
cmpTbl$ave_corr = NA
cmpTbl$median_corr = NA
cmpTbl$ave_max_corr = NA
cmpTbl$median_max_corr = NA
for (i in 1:length(pathways)){
rxnset = annotation$rxn[which(annotation$connected_pathways == pathways[i])]
if (sum(rownames(rows.cor.exp) %in% rxnset)>1){# only analyze the valid coexpression (at least two measured rxns)
tmp0 = rows.cor.exp[rownames(rows.cor.exp) %in% rxnset,
colnames(rows.cor.exp) %in% rxnset]
tmp = c()# we avoid calculate the same PCC twice
for (zz in 1:(ncol(tmp0)-1)){
for (kk in (zz+1):nrow(tmp0)){
tmp = c(tmp, tmp0[zz,kk])
}
}
cmpTbl$ave_coexpression[i] =  mean(tmp,na.rm = T)
cmpTbl$median_coexpression[i] =  median(tmp,na.rm = T)
cmpTbl$ave_FPA_corr[i] = mean(FPAtbl[rxnset,'PCC_by_default_FPA'],na.rm = T)
cmpTbl$median_FPA_corr[i] = median(FPAtbl[rxnset,'PCC_by_default_FPA'],na.rm = T)
cmpTbl$ave_corr[i] = mean(FPAtbl[rxnset,"PCC_by_target_expression"],na.rm = T)
cmpTbl$median_corr[i] = median(FPAtbl[rxnset,'PCC_by_target_expression'],na.rm = T)
cmpTbl$ave_max_corr[i] = mean(FPAtbl[rxnset,"maxPCC"],na.rm = T)
cmpTbl$median_max_corr[i] = median(FPAtbl[rxnset,'maxPCC'],na.rm = T)
}
}
View(cmpTbl)
cmpTbl = cmpTbl[!is.na(cmpTbl$median_coexpression),]
excl = c('Leucine and valine biosynthesis')
cmpTbl_fit = cmpTbl[!(cmpTbl$pathways %in% excl), ]
cmpTbl_excl = cmpTbl[(cmpTbl$pathways %in% excl), ]
View(annotation)
#correlation between coexpression levels and flux-expression concordance levels
ExpMat = read.csv('output/supp1D_normalizedExpression.csv',row.names = 1)
rows.cor.exp <- cor(t(ExpMat), use = "pairwise.complete.obs", method = "pearson")
pathways = setdiff(unique(annotation$connected_pathways),'NA')
cmpTbl = data.frame(pathways)
cmpTbl$ave_coexpression = NA
cmpTbl$median_coexpression = NA
cmpTbl$ave_FPA_corr = NA
cmpTbl$median_FPA_corr = NA
cmpTbl$ave_corr = NA
cmpTbl$median_corr = NA
cmpTbl$ave_max_corr = NA
cmpTbl$median_max_corr = NA
for (i in 1:length(pathways)){
rxnset = annotation$rxn[which(annotation$connected_pathways == pathways[i])]
if (sum(rownames(rows.cor.exp) %in% rxnset)>1){# only analyze the valid coexpression (at least two measured rxns)
tmp0 = rows.cor.exp[rownames(rows.cor.exp) %in% rxnset,
colnames(rows.cor.exp) %in% rxnset]
tmp = c()# we avoid calculate the same PCC twice
for (zz in 1:(ncol(tmp0)-1)){
for (kk in (zz+1):nrow(tmp0)){
tmp = c(tmp, tmp0[zz,kk])
}
}
cmpTbl$ave_coexpression[i] =  mean(tmp,na.rm = T)
cmpTbl$median_coexpression[i] =  median(tmp,na.rm = T)
cmpTbl$ave_FPA_corr[i] = mean(FPAtbl[rxnset,'PCC_by_default_FPA'],na.rm = T)
cmpTbl$median_FPA_corr[i] = median(FPAtbl[rxnset,'PCC_by_default_FPA'],na.rm = T)
cmpTbl$ave_corr[i] = mean(FPAtbl[rxnset,"PCC_by_target_expression"],na.rm = T)
cmpTbl$median_corr[i] = median(FPAtbl[rxnset,'PCC_by_target_expression'],na.rm = T)
cmpTbl$ave_max_corr[i] = mean(FPAtbl[rxnset,"maxPCC"],na.rm = T)
cmpTbl$median_max_corr[i] = median(FPAtbl[rxnset,'maxPCC'],na.rm = T)
}
}
cmpTbl = cmpTbl[!is.na(cmpTbl$median_coexpression),]
excl = c('Leucine and valine biosynthesis')
cmpTbl_fit = cmpTbl[!(cmpTbl$pathways %in% excl), ]
cmpTbl_excl = cmpTbl[(cmpTbl$pathways %in% excl), ]
View(cmpTbl)
# PLOT
dev.off()
pdf('figures/co-expression-flux-accordance.pdf',width = 4,height = 4.3)
fit = lm(median_corr ~median_coexpression, cmpTbl_fit)
plot(cmpTbl_fit$median_coexpression, cmpTbl_fit$median_corr, ylim = c(-1,1), xlim = c(-0.3,1),
xlab = 'Pathway-level co-expression',
ylab = 'Pathway-level flux-expression correlation',
lwd = 1)
text(cmpTbl_fit$median_coexpression, cmpTbl_fit$median_corr, labels=rank(cmpTbl_fit$median_coexpression), cex = 0.3)
abline(fit,lwd = 1,lty = 2)
points(cmpTbl_excl$median_coexpression, cmpTbl_excl$median_corr,col = 'red',pch = 1, lwd = 1)
a = summary(fit)
text(0.8, -0.1,paste('r = ',round(sqrt(a$r.squared),2),sep = ''))
axis(side = 1, lwd = 1)
axis(side = 2, lwd = 1)
dev.off()
cmpTbl_fit$numberInFig = rank(cmpTbl_fit$median_coexpression)
pathwayCounts = data.frame(table(annotation$connected_pathways))
pathwayCounts$valid = 0
for (i in 1:nrow(pathwayCounts)){
rxnset = annotation$rxn[which(annotation$connected_pathways == pathwayCounts$Var1[i])]
pathwayCounts$valid[i]=sum(rownames(rows.cor.exp) %in% rxnset)
}
View(pathwayCounts)
# next, we analyze the pathway level improvement from integration
cmpTbl2 = cmpTbl
cmpTbl2 = cmpTbl2[order(cmpTbl2$median_coexpression),]
View(cmpTbl2)
dev.off()
pdf('figures/co-expression-flux-accordance_deltaPCC.pdf',width = 4,height = 4.3)
y = cmpTbl2$median_max_corr - cmpTbl2$median_corr
x = cmpTbl2$median_coexpression
plot(x, y, ylim = c(-0.1,1.05), xlim = c(-0.3,1),
xlab = 'Pathway-level co-expression',
ylab = 'Pathway-level integration benefit (delta PCC)',
lwd = 1,cex = 0.5,
type = 'p', lty =2)
model <- lm(y ~ poly(x,5))
seq1 = seq(-0.3,1, 0.001)
lines(seq1,predict(model,data.frame(x = seq1)),col='grey',lwd=1)
abline(h = 0,lty = 2)
axis(side = 1, lwd = 1)
axis(side = 2, lwd = 1)
box(lwd=1)
dev.off()
# compare gap filling vs error correcting
summaryData = read.csv('output/summary_table_reaction_information.csv',row.names = 1)
View(summaryData)
table(summaryData$predicted_by_FPA)
table(summaryData$predicted_by_optimal_boundary_FPA)
table(summaryData$predicted_by_default_FPA)
table(summaryData$correlated)
table(summaryData$expression_type)
predType = data.frame(gapfilling = c(NA,NA), correcting = c(NA,NA),row.names = c('local','optimal'))
predType['local',"gapfilling"] = sum(summaryData$predicted_by_default_FPA=='Yes' &
summaryData$expression_type %in% c("No GPR","Not measured") &
summaryData$correlated == 'No')
predType['local',"correcting"] = sum(summaryData$predicted_by_default_FPA=='Yes' &
!(summaryData$expression_type %in% c("No GPR","Not measured")) &
summaryData$correlated == 'No')
predType["optimal","gapfilling"] = sum(summaryData$predicted_by_FPA=='Yes' &
summaryData$expression_type %in% c("No GPR","Not measured") &
summaryData$correlated == 'No')
predType['optimal',"correcting"] = sum(summaryData$predicted_by_FPA=='Yes' &
!(summaryData$expression_type %in% c("No GPR","Not measured")) &
summaryData$correlated == 'No')
predType
predType["optimal","gapfilling"] = sum(summaryData$predicted_by_optimal_boundary_FPA=='Yes' &
summaryData$expression_type %in% c("No GPR","Not measured") &
summaryData$correlated == 'No')
predType['optimal',"correcting"] = sum(summaryData$predicted_by_optimal_boundary_FPA=='Yes' &
!(summaryData$expression_type %in% c("No GPR","Not measured")) &
summaryData$correlated == 'No')
predType
# show predictions of all rxn in venn plot
library(eulerr)
dev.off()
pdf('figures/rxn_venn.pdf',width = 7,height = 7)
plot(euler(list(all = summaryData$rxnID,
expression_only=summaryData$rxnID[summaryData$correlated == 'Yes'],
localFPA=summaryData$rxnID[summaryData$predicted_by_default_FPA == 'Yes'],
optimalFPA = summaryData$rxnID[summaryData$predicted_by_FPA == 'Yes'])), quantities = TRUE)
dev.off()
dev.off()
pdf('figures/rxn_venn.pdf',width = 7,height = 7)
plot(euler(list(all = summaryData$rxnID,
expression_only=summaryData$rxnID[summaryData$correlated == 'Yes'],
localFPA=summaryData$rxnID[summaryData$predicted_by_default_FPA == 'Yes'],
optimalFPA = summaryData$rxnID[summaryData$predicted_by_optimal_boundary_FPA == 'Yes'])), quantities = TRUE)
dev.off()
summaryData$rxnID[summaryData$predicted_by_optimal_boundary_FPA == 'Yes']
summaryData$rxnID[summaryData$predicted_by_optimal_boundary_FPA == 'Yes']
summaryData$predicted_by_optimal_boundary_FPA
summaryData$predicted_by_optimal_boundary_FPA == 'Yes'
dev.off()
pdf('figures/rxn_venn.pdf',width = 7,height = 7)
plot(euler(list(all = rownames(summaryData),
expression_only=rownames(summaryData)[summaryData$correlated == 'Yes'],
localFPA=rownames(summaryData)[summaryData$predicted_by_default_FPA == 'Yes'],
optimalFPA = rownames(summaryData)[summaryData$predicted_by_optimal_boundary_FPA == 'Yes'])), quantities = TRUE)
dev.off()
# classify the new predictions
dev.off()
pdf('figures/pred_type_local.pdf',width = 7,height = 7)
pie(as.numeric(predType[1,]), colnames(predType),main = paste('gapfill = ',predType[1,1], ' correcting = ',predType[1,2],sep = ''))
dev.off()
dev.off()
pdf('figures/pred_type_optimal.pdf',width = 7,height = 7)
pie(as.numeric(predType[2,]), colnames(predType),main = paste('gapfill = ',predType[2,1], ' correcting = ',predType[2,2],sep = ''))
dev.off()
# directly compare the PCC for understanding the benefit
PCC_all = read.csv('output/PCC_titration_all.csv',row.names = 1);
sig = read.csv('output/heatmapTbl_sigLabel.csv',row.names = 1)
boundary = data.frame(Var1 = c(c('base2-boundary6','expression only'), seq(0,40,0.5)))
colnames(PCC_all) = boundary$Var1
infoTbl = read.csv('output/summary_table_reaction_information.csv')
validRxns = infoTbl$rxnID[!infoTbl$expression_type %in% c('Not measured','No GPR')]
PCC_all = PCC_all[validRxns,]
library(matrixStats)
PCC_all$max = rowMaxs(as.matrix(PCC_all[,3:ncol(PCC_all)]))
dev.off()
pdf('figures/PCC_comparison.pdf',width = 7,height = 7)
plot(PCC_all$`expression only`, PCC_all$max, col = 'black', lwd = 2,pch =16,
xlab = 'PCC by target expression',
ylab = 'PCC by optimal boundary integration')
abline(a = 0,b = 1,lwd = 2,lty = 2)
abline(v = -0.4,lwd = 1,lty = 2)
abline(v = 0.4,lwd = 1,lty = 2)
axis(side = 1, lwd = 2)
axis(side = 2, lwd = 2)
box(lwd=2)
dev.off()
